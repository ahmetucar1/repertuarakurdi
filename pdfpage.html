<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PDF Sayfa</title>
  <style>
    html, body { margin:0; padding:0; background:transparent; overflow:hidden; }
    .wrap{ width:100%; position:relative; }
    canvas{ display:block; width:100%; height:auto; max-width:none; }
    .overlay{ position:absolute; left:0; top:0; pointer-events:none; user-select:none; }

    /* Akor kutusu — minimal padding, gölgesiz */
    .ch{
      position:absolute;
      font:800 14px/1 system-ui,-apple-system,Segoe UI,Roboto,Arial;
      color:#111;
      padding:0 2px;
      border-radius:2px;
      white-space:nowrap;
      background:#fff;
      pointer-events:none;
      user-select:none;
      isolation:isolate;
      z-index:11;
      box-shadow: none;
    }

    .ch::before{ display:none; }

    .overlay{ position:absolute; left:0; top:0; z-index:10; }




    .err{ font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; padding:16px; color:#fff; }
  </style>
</head>
<body>
  <div class="wrap" id="wrap">
    <canvas id="c"></canvas>
    <div class="overlay" id="overlay"></div>
  </div>

  <script type="module">
    import * as pdfjsLib from "./pdfjs/build/pdf.mjs";
    pdfjsLib.GlobalWorkerOptions.workerSrc = "./pdfjs/build/pdf.worker.mjs";

    const p = new URLSearchParams(location.search);
    const file = p.get("file");
    const pageNo = Number(p.get("page") || "1");
    const fileBase = (file || "").split("/").pop() || "";
    const chordJsonUrl = fileBase ? `assets/chords/${fileBase.replace(/\\.pdf$/i,"")}.json` : "";
    const cleanImgBase = ""; // PDFJS render kullan; temiz PNG denemesini kapattık

    const wrap = document.getElementById("wrap");
    const canvas = document.getElementById("c");
    const overlay = document.getElementById("overlay");
    const ctx = canvas.getContext("2d", { alpha: true });

    let SEMITONES = 0;
    let CHORDS = [];

    // --- Transpoze altyapısı ---
    const NOTE_TO_I = {
      "C":0, "B#":0,
      "C#":1, "Db":1,
      "D":2,
      "D#":3, "Eb":3,
      "E":4, "Fb":4,
      "F":5, "E#":5,
      "F#":6, "Gb":6,
      "G":7,
      "G#":8, "Ab":8,
      "A":9,
      "A#":10, "Bb":10,
      "B":11, "Cb":11
    };
    const I_TO_SHARP = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
    const I_TO_FLAT  = ["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"];

    function mod(n,m){ return ((n % m) + m) % m; }

    const NAMES_SHARP = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
    const NAMES_FLAT  = ["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"];

    function pickPrefer(symbol, fallback="sharp"){
      const s = symbol || "";
      if(s.includes("b") && !s.includes("#")) return "flat";
      if(s.includes("#") && !s.includes("b")) return "sharp";
      return fallback;
    }

    function transposeNote(note, semis, preferFlats){
      const i = NOTE_TO_I[note];
      if(i == null || !Number.isFinite(semis)) return note;
      const out = mod(i + semis, 12);
      return (preferFlats ? NAMES_FLAT : NAMES_SHARP)[out];
    }

    // Güçlü akor transpozisyonu: kök + gövde + slash bası
    function splitSlash(body){
      let depth = 0;
      for(let i=0; i<body.length; i++){
        const ch = body[i];
        if(ch === "(") depth++;
        else if(ch === ")" && depth > 0) depth--;
        else if(ch === "/" && depth === 0){
          return [body.slice(0,i), body.slice(i+1)];
        }
      }
      return [body, ""];
    }

    function transposeChord(chord, semis, opts = {}){
      const raw = (chord || "").trim();
      if(!raw || !Number.isFinite(semis) || semis % 12 === 0) return raw;

      const m = raw.match(/^([A-G])([#b]?)(.*)$/);
      if(!m) return raw;

      const [, root, accidental, tail] = m;
      const [body, slashPart] = splitSlash(tail || "");

      const prefer = opts.prefer ?? pickPrefer(raw, opts.fallbackPrefer || "sharp");
      const preferFlats = prefer === "flat";

      const tRoot = transposeNote(root + (accidental || ""), semis, preferFlats);

      let bassOut = "";
      if(slashPart){
        const bm = slashPart.match(/^([A-G])([#b]?)(.*)$/);
        if(bm){
          const bRoot = bm[1] + (bm[2] || "");
          const tBass = transposeNote(bRoot, semis, preferFlats);
          bassOut = "/" + tBass + (bm[3] || "");
        } else {
          bassOut = "/" + slashPart; // dokunma
        }
      }

      return tRoot + body + bassOut;
    }

    function showError(msg){
      document.body.innerHTML = `<div class="err">${msg}</div>`;
    }

    // --- Akor yakalama / filtre ---
    function cleanTok(tok){
      if(!tok) return "";
      // sondaki noktalama vs
      return tok.replace(/[.,;:!?]+$/g, "");
    }

    // Akor token regex (çok agresif yapmıyoruz; satır filtresi asıl işi yapacak)
    const CHORD_RE = /^[A-G](?:#|b)?(?:maj|min|m|dim|aug|sus|add)?\d*(?:[b#]\d+)?(?:\([^)]*\))?(?:\/[A-G](?:#|b)?)?$/;

    function isChordToken(tok){
      tok = cleanTok(tok.trim());
      if(!tok) return false;
      if(/^N\.?C\.?$/i.test(tok)) return false;
      // tek başına tire/bar vs olmasın
      if(/^[-–—|]+$/.test(tok)) return false;
      if(tok.length > 12) return false;
      return CHORD_RE.test(tok);
    }

    // Satır içinde “harfli kelime” var mı?
    function hasWordLetters(tok){
      // en az 2 harfli kelime gibi düşün (Em gibi 2 harf burada yakalanabilir ama satır filtresi çözecek)
      return /[A-Za-zÇĞİÖŞÜçğıöşü]{2,}/.test(tok);
    }

    function yBucket(px){ return Math.round(px / 10); }  // satır kovası
    function xBucket(px){ return Math.round(px / 6); }   // yakınlık kovası

    function median(arr){
      if(!arr.length) return 0;
      const a = arr.slice().sort((x,y)=>x-y);
      const mid = Math.floor(a.length/2);
      return a.length % 2 ? a[mid] : (a[mid-1]+a[mid])/2;
    }

    function postParent(msg){
      try{ window.parent?.postMessage(msg, location.origin); }catch(e){}
    }

    function loadImage(url){
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = url;
      });
    }

    async function loadChordData(pageNo){
      if(!chordJsonUrl) return null;
      try{
        const res = await fetch(chordJsonUrl, { cache: "no-store" });
        if(!res.ok) return null;
        const data = await res.json();
        const arr = data?.pages?.[String(pageNo)] || [];
        const meta = data?.meta || {};
        return { chords: Array.isArray(arr) ? arr : [], meta };
      }catch(e){
        return null;
      }
    }

    function applyTranspose(){
      for(const c of CHORDS){
        c.el.textContent = transposeChord(c.original, SEMITONES, { prefer: pickPrefer(c.original) });
      }
    }

    if(!file){
      showError("Xeta: 'file' parametresi yok.");
    } else {
      try{
        const loadingTask = pdfjsLib.getDocument({ url: file });
        const pdf = await loadingTask.promise;
        const page = await pdf.getPage(Math.max(1, Math.min(pageNo, pdf.numPages)));

        async function render(){
          CHORDS = [];
          overlay.innerHTML = "";

          const dpr = window.devicePixelRatio || 1;
          const maxW = Math.max(1, wrap.clientWidth);

          const viewportBase = page.getViewport({ scale: 1 });
          const viewport0 = viewportBase;
          const scale = maxW / viewportBase.width;
          const viewport = page.getViewport({ scale });

          canvas.width = Math.floor(viewport.width * dpr);
          canvas.height = Math.floor(viewport.height * dpr);
          canvas.style.width = `${Math.floor(viewport.width)}px`;
          canvas.style.height = `${Math.floor(viewport.height)}px`;

          overlay.style.width = `${Math.floor(viewport.width)}px`;
          overlay.style.height = `${Math.floor(viewport.height)}px`;

          const transform = [dpr, 0, 0, dpr, 0, 0];
          await page.render({ canvasContext: ctx, viewport, transform }).promise;

          const chordData = await loadChordData(pageNo);
          const titleSafeY = viewport.height * 0.12; // başlık alanını koru
          const bottomSafeStart = viewport.height * 0.9; // alt bandı biraz daha genişlet

          if(chordData?.chords?.length){
            const meta = chordData.meta || {};
            const normalized = meta.normalized !== false;
            const baseW = Number(meta.viewportWidth) || viewport0.width;
            const baseH = Number(meta.viewportHeight) || viewport0.height;
            const scaleX = baseW ? viewport.width / baseW : scale;
            const scaleY = baseH ? viewport.height / baseH : scale;

            for(const c of chordData.chords){
              const rawText = c.text || c.t || c.chord || "";
              if(!rawText) continue;
              const cx = Number(c.x) || 0;
              const cy = Number(c.y) || 0;
              const fs = Number(c.fs || c.fontSize) || 14;
              const cw = Number(c.w);
              const ch = Number(c.h);

              const px = normalized ? cx * viewport.width : cx * scaleX;
              const py = normalized ? cy * viewport.height : cy * scaleY;
              const fpx = fs * scaleX;

              if(py < titleSafeY || py > bottomSafeStart) continue;

              const useNorm = c.w != null && c.h != null;
              const pw = useNorm ? Math.max(10, cw * viewport.width * 1.1) : Math.max(12, rawText.length * fpx * 0.7);
              const ph = useNorm ? Math.max(10, ch * viewport.height * 1.15) : Math.max(12, fpx * 1.15);

              // Eski akoru canvasta beyazla sil (sadece bbox kadar)
              ctx.save();
              ctx.globalCompositeOperation = "source-over";
              ctx.fillStyle = "#fff";
              ctx.fillRect(px, py - ph*0.12, Math.min(pw, viewport.width*0.4), Math.min(ph, fpx*1.5));
              ctx.restore();

              const el = document.createElement("span");
              el.className = "ch";
              el.textContent = transposeChord(rawText, SEMITONES, { prefer: pickPrefer(rawText) });
              el.style.left = `${Math.max(0, px)}px`;
              el.style.top  = `${Math.max(0, py)}px`;
              el.style.fontSize = `${Math.round(fpx)}px`;
              el.style.padding = "0 2px";

              overlay.appendChild(el);
              CHORDS.push({ el, original: rawText });
            }
          } else {
            const text = await page.getTextContent();
            const items = text.items || [];

            // Önce sayfadaki font boylarının medyanını al (başlığı yakalayıp elemek için)
            const fontSizes = [];
            for(const it of items){
              if(!it || !it.str) continue;
              const fs = Math.max(10, Math.hypot(it.transform?.[0]||0, it.transform?.[1]||0) * viewport.scale);
              fontSizes.push(fs);
            }
            const medFs = median(fontSizes) || 14;
            const titleFsThreshold = Math.max(24, medFs * 1.75);

            // Adayları satır bazında topla
            // lineKey -> { chords:[], nonChordLetterCount:int, tokenCount:int, maxFs:float }
            const lines = new Map();

            for(const it of items){
              const raw = (it.str || "").trim();
              if(!raw) continue;

              // item başlangıcı
              const [xStart, yStart] = viewport.convertToViewportPoint(it.transform[4], it.transform[5]);
              const fontSize = Math.max(10, Math.hypot(it.transform[0], it.transform[1]) * viewport.scale);
              const totalW = (it.width || 0) * viewport.scale;
              const top = Math.max(0, yStart - fontSize);

              // Başlık gibi büyük fontları tamamen ignore et
              if(fontSize >= titleFsThreshold) continue;

              // token çıkar (konum için index lazım)
              const toks = [];
              const re = /\S+/g;
              let m;
              while((m = re.exec(raw))){
                const t = cleanTok(m[0]);
                if(!t) continue;
                toks.push({ tok:t, idx:m.index });
              }
              if(!toks.length) continue;

              const lineKey = yBucket(top);

              let line = lines.get(lineKey);
              if(!line){
                line = { chords:[], nonChordLetterCount:0, tokenCount:0, maxFs:0 };
                lines.set(lineKey, line);
              }

              line.tokenCount += toks.length;
              if(fontSize > line.maxFs) line.maxFs = fontSize;

              // Akor adaylarını ve söz göstergelerini topla
              for(const t of toks){
                if(isChordToken(t.tok)){
                  // token'ın metin içindeki konumuna göre x'i orantıla
                  const rel = t.idx / Math.max(1, raw.length);
                  const x = xStart + (totalW ? totalW * rel : 0);

                  line.chords.push({
                    tok: t.tok,
                    x,
                    top,
                    fontSize
                  });
                } else {
                  // “söz kelimesi” göstergesi
                  if(hasWordLetters(t.tok)) line.nonChordLetterCount++;
                }
              }
            }

            // Satır seçimi + basma
            const used = new Set();

            for(const [lk, line] of lines.entries()){
              const chordCount = line.chords.length;
              if(!chordCount) continue;

              // Başlık/etiket satırlarını koru (maxFs aşırı büyükse)
              if(line.maxFs >= titleFsThreshold) continue;

              const ratio = chordCount / Math.max(1, line.tokenCount);

              // 1) Söz ağırlıklı satırlara akor basma
              if(line.nonChordLetterCount >= 2 && ratio < 0.45){
                continue;
              }

              // 2) Akor satırı kabul kuralları (kaçırmayı azaltacak şekilde)
              let accept = false;

              if(chordCount >= 3){
                accept = ratio >= 0.30;
              } else if(chordCount === 2){
                accept = ratio >= 0.40;
              } else {
                // Tek akor: sadece “tek başına duran chord” gibi görünüyorsa kabul et
                const only = line.chords[0].tok;
                const isSingleRoot = /^[A-G](?:#|b)?$/.test(only);
                // Söz kelimesi yoksa ve token sayısı da çok değilse (satır komple söz olmasın)
                if(line.nonChordLetterCount <= 1 && line.tokenCount <= 3){
                  // tek harf kökleri de kabul et ama çok agresif olmasın
                  accept = isSingleRoot || only.length >= 2;
                }
              }

              if(!accept) continue;

              // Aynı satırdaki chordları sırala
              line.chords.sort((a,b) => a.x - b.x);

              for(const c of line.chords){
                const key = `${xBucket(c.x)}|${lk}`;
                if(used.has(key)) continue;
                used.add(key);

                const el = document.createElement("span");
                el.className = "ch";
                el.textContent = transposeChord(c.tok, SEMITONES, { prefer: pickPrefer(c.tok) });
                el.style.left = `${Math.max(0, c.x)}px`;
                el.style.top  = `${Math.max(0, c.top)}px`;
                el.style.fontSize = `${Math.round(c.fontSize)}px`;
                const padX = Math.max(3, c.fontSize * 0.18 + (c.tok?.length || c.original?.length || 0) * 0.25);
                const padY = Math.max(2, c.fontSize * 0.18);
                el.style.paddingLeft = `${padX}px`;
                el.style.paddingRight = `${padX}px`;
                el.style.paddingTop = `${padY}px`;
                el.style.paddingBottom = `${padY}px`;

                overlay.appendChild(el);
                CHORDS.push({ el, original: c.tok });
              }
            }
          }

          // render sonrası: ebeveyne yükseklik + akor sayısı bildir
          postParent({ type: "pdfpage:height", height: Math.round(viewport.height) });
          postParent({ type: "pdfpage:chords", count: CHORDS.length });
        }

        // İlk render + resize
        let resizeT = null;
        const rerender = () => {
          clearTimeout(resizeT);
          resizeT = setTimeout(() => render().catch(err=>showError("Xeta: " + (err?.message || err))), 120);
        };

        await render();
        window.addEventListener("resize", rerender);

        // Ton değişimi (parent'tan gelir)
        window.addEventListener("message", (e) => {
          if(e.origin !== location.origin) return;
          const d = e.data;
          if(!d || d.type !== "pdfpage:transpose") return;
          const n = Number(d.semitones);
          if(Number.isFinite(n)){
            SEMITONES = n;
            applyTranspose();
          }
        });

      }catch(err){
        showError("Xeta: " + (err?.message || err));
      }
    }
  </script>
</body>
</html>
